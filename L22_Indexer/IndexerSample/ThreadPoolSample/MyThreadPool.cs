using System.Collections.Concurrent;namespace ThreadPoolSample;public class MyThreadPool{        public static ulong currentId = 0;    public static readonly BlockingCollection<(ulong , Action , ExecutionContext?)> actions = [];       public static void QueueUserWorkItem(Action action) => actions.Add((Interlocked.Increment(ref currentId), action, ExecutionContext.Capture()));    static MyThreadPool()    {        Console.WriteLine($"ThreadPool is started with {Environment.ProcessorCount} threads.");#if Pro_Version        int threadCount = Environment.ProcessorCount;#else        int threadCount = Environment.ProcessorCount < 2 ? Environment.ProcessorCount : 2 ;#endif                Console.WriteLine($"threadCount #{threadCount} threads.");        #region Thread Pool        for (int i = 0; i < threadCount; i++)        {            var t = new Thread((threadId) =>            {                Console.WriteLine($"Thread #{Environment.CurrentManagedThreadId} is started.");                while (true)                {                    (ulong id, Action action, ExecutionContext? context) = actions.Take();                    Console.WriteLine($"Thread #{Environment.CurrentManagedThreadId} is processing task #{id}.");                    if (context is null)                    {                        action();                    }                    else                    {                        ExecutionContext.Run(context, state=>((Action)state!).Invoke(), action);                    }                }            })            {                IsBackground = true            };            t.Start();        }        #endregion            }    }
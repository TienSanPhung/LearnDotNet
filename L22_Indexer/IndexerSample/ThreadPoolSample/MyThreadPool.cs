using System.Collections.Concurrent;namespace ThreadPoolSample;public class MyThreadPool{    public static ulong currentId = 0;    public static readonly BlockingCollection<(ulong , Action , ExecutionContext?)> actions = [];        public static void QueueUserWorkItem(Action action) => actions.Add((Interlocked.Increment(ref currentId), action, ExecutionContext.Capture()));    static MyThreadPool()    {        for (int i = 0; i < Environment.ProcessorCount; i++)        {            var t = new Thread((threadId) =>            {                Console.WriteLine($"Thread #{Environment.CurrentManagedThreadId} is started.");                while (true)                {                    (ulong id, Action action, ExecutionContext? context) = actions.Take();                    Console.WriteLine($"Thread #{Environment.CurrentManagedThreadId} is processing task #{id}.");                    if (context is null)                    {                        action();                    }                    else                    {                        ExecutionContext.Run(context, state=>((Action)state!).Invoke(), action);                    }                }            })            {                IsBackground = true            };            t.Start();        }    }    }